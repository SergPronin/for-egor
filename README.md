# Руководство по Калькулятору Матриц

Этот документ объясняет, как работает Java-программа для работы с матрицами, включая математическую теорию, подробный разбор кода и примеры использования. Программа позволяет выполнять следующие операции:
1. Вычисление определителя матрицы.
2. Решение системы уравнений методом Крамера.
3. Приведение матрицы к верхнетреугольной форме.
4. Решение системы уравнений методом Гаусса.
5. Нахождение обратной матрицы 2x2 с проверкой.
6. Умножение двух квадратных матриц.
7. Нахождение обратной матрицы произвольного размера.

Программа состоит из четырёх файлов:
- `MatrixCalculatorUI.java`: Графический интерфейс.
- `att1.java`: Определитель, метод Крамера, треугольная форма.
- `att2.java`: Метод Гаусса.
- `att3.java`: Обратная матрица 2x2, умножение матриц, обратная матрица любого размера.

## Часть 1: Математическая теория

### 1. Что такое матрица?
Матрица — это прямоугольная таблица чисел, организованная в строки и столбцы. Например, матрица 2x3 выглядит так:

```
[ 1  2  3 ]
[ 4  5  6 ]
```

Здесь 2 строки и 3 столбца. Матрица называется **квадратной**, если число строк равно числу столбцов (например, 2x2 или 3x3).

### 2. Определитель матрицы
**Определитель** (или детерминант) — это число, которое можно вычислить только для квадратной матрицы. Оно используется для проверки, есть ли у матрицы обратная, и для решения систем уравнений.

- **Для матрицы 1x1**: 
  ```
  [a] → det = a
  ```

- **Для матрицы 2x2**:
  ```
  [ a  b ]
  [ c  d ] → det = a*d - b*c
  ```

- **Для матрицы 3x3 и больше**: Используется разложение по строке:
  - Выбираем строку (например, первую).
  - Для каждого элемента умножаем его на **кофактор** и суммируем.
  - Кофактор = (-1)^(i+j) * определитель минора.
  - Минор — матрица, полученная удалением i-й строки и j-го столбца.

**Пример**:
```
[ 1  2  3 ]
[ 4  5  6 ]
[ 7  8  9 ]
```
Разложим по первой строке:
- Для 1: Кофактор = (-1)^(1+1) * det([5 6; 8 9]) = 1 * (5*9 - 6*8) = 1 * (45 - 48) = -3
- Для 2: Кофактор = (-1)^(1+2) * det([4 6; 7 9]) = -1 * (4*9 - 6*7) = -1 * (36 - 42) = 6
- Для 3: Кофактор = (-1)^(1+3) * det([4 5; 7 8]) = 1 * (4*8 - 5*7) = 1 * (32 - 35) = -3
- det = 1*(-3) + 2*6 + 3*(-3) = -3 + 12 - 9 = 0

### 3. Метод Крамера
Метод Крамера решает систему линейных уравнений вида **Ax = B**, где:
- **A** — квадратная матрица коэффициентов.
- **B** — вектор свободных членов.
- **x** — вектор неизвестных (x1, x2, ...).

**Шаги**:
1. Вычислить определитель матрицы **A** (det(A)).
2. Если det(A) = 0, решения нет или их бесконечно много.
3. Для каждой переменной xi:
   - Заменить i-й столбец матрицы **A** на вектор **B**, получить матрицу **Ai**.
   - Вычислить det(Ai).
   - xi = det(Ai) / det(A).

**Пример**:
```
2x1 + x2 = 5
x1 + 3x2 = 4
```
Матрица A:
```
[ 2  1 ]
[ 1  3 ]
```
Вектор B:
```
[ 5 ]
[ 4 ]
```
- det(A) = 2*3 - 1*1 = 6 - 1 = 5
- A1 (заменяем 1-й столбец на B):
  ```
  [ 5  1 ]
  [ 4  3 ] → det(A1) = 5*3 - 1*4 = 15 - 4 = 11 → x1 = 11/5 = 2.2
  ```
- A2 (заменяем 2-й столбец на B):
  ```
  [ 2  5 ]
  [ 1  4 ] → det(A2) = 2*4 - 5*1 = 8 - 5 = 3 → x2 = 3/5 = 0.6
  ```

### 4. Верхнетреугольная форма
Матрица называется **верхнетреугольной**, если все элементы ниже главной диагонали равны нулю:
```
[ a  b  c ]
[ 0  d  e ]
[ 0  0  f ]
```
**Шаги приведения**:
1. Используем элементарные преобразования строк:
   - Сложение строки с другой, умноженной на константу.
   - Перестановка строк.
2. Обнуляем элементы под диагональю, двигаясь слева направо.
3. Определитель такой матрицы равен произведению диагональных элементов, с учётом знака от перестановок строк.

**Пример**:
```
[ 1  2  3 ]
[ 4  5  6 ]
[ 7  8  9 ]
```
- Вычтем из 2-й строки 4*1-ю, из 3-й — 7*1-ю:
  ```
  [ 1  2   3  ]
  [ 0  -3  -6 ]
  [ 0  -6  -12 ]
  ```
- Вычтем из 3-й строки 2*2-ю:
  ```
  [ 1  2   3  ]
  [ 0  -3  -6 ]
  [ 0  0   0  ]
  ```
Определитель: 1 * (-3) * 0 = 0 (с учётом знака перестановок, если были).

### 5. Метод Гаусса
Метод Гаусса решает систему **Ax = B** путём приведения расширенной матрицы [A|B] к ступенчатому виду. Возможны три исхода:
1. **Одно решение**: Ранг матрицы A равен рангу [A|B] и числу неизвестных.
2. **Бесконечное число решений**: Ранг меньше числа неизвестных.
3. **Нет решений**: Ранг [A|B] больше ранга A.

**Шаги**:
1. Составить расширенную матрицу [A|B].
2. Привести к ступенчатому виду (прямой ход).
3. Проверить ранги.
4. Если решение единственное, выполнить обратный ход для нахождения x.

**Пример**:
```
x1 + x2 = 3
2x1 + 2x2 = 6
```
Расширенная матрица:
```
[ 1  1  |  3 ]
[ 2  2  |  6 ]
```
- Вычтем из 2-й строки 2*1-ю:
  ```
  [ 1  1  |  3 ]
  [ 0  0  |  0 ]
  ```
- Ранг A = 1, ранг [A|B] = 1, неизвестных = 2 → бесконечное число решений.

### 6. Обратная матрица
Обратная матрица **A^-1** для квадратной матрицы **A** удовлетворяет: **A * A^-1 = I**, где **I** — единичная матрица (1 на диагонали, 0 в остальных местах).

- **Для матрицы 2x2**:
  ```
  [ a  b ] → det = a*d - b*c
  [ c  d ]
  ```
  Если det ≠ 0:
  ```
  A^-1 = (1/det) * [ d  -b ]
                   [ -c  a ]
  ```

- **Для матрицы любого размера** (метод Гаусса-Жордана):
  1. Составить матрицу [A|I].
  2. Привести левую часть к единичной матрице.
  3. Правая часть станет A^-1.
  4. Если det = 0, обратной матрицы нет.

**Пример (2x2)**:
```
[ 1  2 ]
[ 3  4 ]
```
- det = 1*4 - 2*3 = 4 - 6 = -2
- A^-1 = (1/-2) * [ 4  -2 ] = [ -2   1  ]
                  [ -3  1 ]   [ 1.5 -0.5 ]
- Проверка: A * A^-1 = [ 1  0 ]
                       [ 0  1 ]

### 7. Умножение матриц
Умножение матриц A (m×n) и B (n×p) даёт матрицу C (m×p). Элемент C[i][j] — сумма произведений элементов i-й строки A и j-го столбца B.

**Пример**:
```
[ 1  2 ] * [ 5  6 ] = [ 1*5 + 2*7  1*6 + 2*8 ] = [ 19  22 ]
[ 3  4 ]   [ 7  8 ]   [ 3*5 + 4*7  3*6 + 4*8 ]   [ 43  50 ]
```

В программе умножение ограничено квадратными матрицами.

## Часть 2: Объяснение кода

### 1. `MatrixCalculatorUI.java`
Этот файл создаёт графический интерфейс с двумя таблицами (матрицы A и B), кнопками операций и областью вывода.

#### Общий обзор
- **Класс**: `MatrixCalculatorUI` наследуется от `JFrame` (окно Swing).
- **Пакет**: `ml` (все файлы находятся в папке `src/ml`).
- **Компоненты**:
  - `matrixTableA`, `matrixTableB`: Таблицы для ввода матриц.
  - `modelA`, `modelB`: Модели данных таблиц.
  - `outputArea`: Текстовое поле для результатов.
  - `basicOps`, `gaussSolver`, `advancedOps`: Экземпляры классов `att1`, `att2`, `att3`.
- **Методы**:
  - `initializeUI()`: Создаёт панели, таблицы, кнопки.
  - `createMatrixPanel()`: Создаёт панель для таблицы с кнопками управления.
  - `createButton()`: Создаёт стилизованную кнопку.
  - `getMatrixFromTable()`: Преобразует таблицу в массив чисел.
  - Методы операций (например, `computeDeterminant()`): Вызывают методы из `att1`, `att2`, `att3`.

#### Подробный разбор
- **Конструктор**:
  ```java
  public MatrixCalculatorUI() {
      setTitle("Калькулятор матриц");
      setSize(1200, 800);
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setLayout(new BorderLayout(10, 10));
      getContentPane().setBackground(new Color(30, 30, 30));
      initializeUI();
  }
  ```
  - Устанавливает заголовок, размер, действие при закрытии.
  - `BorderLayout` делит окно на области: центр (таблицы), запад (кнопки операций), юг (вывод).
  - Фон тёмно-серый (`RGB(30, 30, 30)`).

- **Метод `initializeUI()`**:
  ```java
  JPanel matrixPanel = new JPanel(new GridLayout(1, 2, 10, 10));
  matrixPanel.setBackground(new Color(30, 30, 30));
  matrixPanel.add(createMatrixPanel("Матрица A", modelA = new DefaultTableModel(3, 3), matrixTableA = new JTable(modelA)));
  matrixPanel.add(createMatrixPanel("Матрица B", modelB = new DefaultTableModel(3, 1), matrixTableB = new JTable(modelB)));
  add(matrixPanel, BorderLayout.CENTER);
  ```
  - Создаёт две таблицы: A (3x3) и B (3x1, вектор-столбец).
  - `GridLayout(1, 2)` располагает таблицы горизонтально.
  - Добавляет панель в центр окна.

  ```java
  JPanel operationPanel = new JPanel(new GridLayout(7, 1, 5, 5));
  operationPanel.add(createButton("Вычислить определитель", e -> computeDeterminant()));
  ...
  add(operationPanel, BorderLayout.WEST);
  ```
  - Создаёт 7 кнопок для операций, расположенных вертикально.
  - Каждая кнопка вызывает соответствующий метод.

  ```java
  outputArea = new JTextArea(15, 50);
  outputArea.setBackground(new Color(50, 50, 50));
  outputArea.setForeground(Color.WHITE);
  JScrollPane outputScroll = new JScrollPane(outputArea);
  outputScroll.setBackground(new Color(30, 30, 30));
  outputScroll.getViewport().setBackground(new Color(30, 30, 30));
  add(outputScroll, BorderLayout.SOUTH);
  ```
  - Создаёт текстовую область для вывода с тёмным фоном.
  - `JScrollPane` добавляет прокрутку, фон синхронизирован.

- **Метод `createMatrixPanel()`**:
  ```java
  table.setBackground(new Color(40, 40, 40));
  table.setForeground(Color.WHITE);
  table.setGridColor(Color.GRAY);
  table.setShowGrid(true);
  ```
  - Настраивает таблицу: тёмный фон, белый текст, серые границы.
  - `setShowGrid(true)` делает сетку видимой.

  ```java
  JScrollPane scrollPane = new JScrollPane(table);
  scrollPane.setBackground(new Color(30, 30, 30));
  scrollPane.getViewport().setBackground(new Color(30, 30, 30));
  ```
  - Устанавливает тёмный фон для области прокрутки и её viewport, чтобы избежать белого фона.

  ```java
  controlPanel.add(createButton("Добавить строку", e -> model.setRowCount(model.getRowCount() + 1)));
  ```
  - Добавляет кнопки для изменения размера таблицы (добавить/удалить строки/столбцы).

- **Метод `getMatrixFromTable()`**:
  ```java
  try {
      matrix[i][j] = value == null || value.toString().trim().isEmpty() ? 0.0 : Double.parseDouble(value.toString().trim());
  } catch (NumberFormatException e) {
      throw new IllegalArgumentException("Ошибка в ячейке [" + (i + 1) + "," + (j + 1) + "]: введите число");
  }
  ```
  - Преобразует данные таблицы в массив чисел.
  - Пустые ячейки интерпретируются как 0.
  - При вводе нечисловых данных выдаёт ошибку.

- **Методы операций**:
  ```java
  private void computeDeterminant() {
      try {
          double[][] matrix = getMatrixFromTable(matrixTableA, modelA);
          outputArea.setText("Результат:\n" + basicOps.calculateDeterminant(matrix));
      } catch (Exception e) {
          outputArea.setText("Ошибка: " + e.getMessage());
      }
  }
  ```
  - Каждый метод получает матрицу(ы) из таблицы, вызывает метод из `att1`, `att2` или `att3`, и выводит результат или ошибку.

#### Пример использования
**Ввод**:
- Матрица A:
  ```
  [ 1  2 ]
  [ 3  4 ]
  ```
- Нажать кнопку "Вычислить определитель".

**Ожидаемый вывод**:
```
Результат:
Определитель: -2.0
```

### 2. `att1.java`
Содержит базовые операции: определитель, метод Крамера, треугольная форма.

#### Общий обзор
- **Класс**: `att1`.
- **Методы**:
  - `calculateDeterminant()`: Вычисляет определитель.
  - `solveByCramer()`: Решает систему методом Крамера.
  - `toTriangularForm()`: Приводит к верхнетреугольной форме.
  - Вспомогательные: `computeDeterminant()`, `computeCofactor()`, `getMinor()`, `copyMatrix()`, `swapRows()`, `makeUpperTriangular()`.

#### Подробный разбор
- **Метод `calculateDeterminant()`**:
  ```java
  if (matrix.length != matrix[0].length) {
      throw new IllegalArgumentException("Матрица должна быть квадратной для вычисления определителя");
  }
  return "Определитель: " + computeDeterminant(matrix);
  ```
  - Проверяет, что матрица квадратная.
  - Вызывает рекурсивный метод `computeDeterminant()`.

- **Метод `computeDeterminant()`**:
  ```java
  if (n == 1) return matrix[0][0];
  if (n == 2) return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
  double det = 0;
  for (int j = 0; j < n; j++) {
      det += matrix[0][j] * computeCofactor(matrix, 0, j);
  }
  ```
  - Для 1x1 и 2x2 использует простые формулы.
  - Для больших матриц разлагает по первой строке, суммируя произведения элементов и их кофакторов.

- **Метод `solveByCramer()`**:
  ```java
  if (A.length != A[0].length || A.length != B.length || B[0].length != 1) {
      throw new IllegalArgumentException("Матрица A должна быть квадратной, B - вектор-столбец");
  }
  double detA = computeDeterminant(A);
  if (Math.abs(detA) < EPSILON) {
      throw new IllegalArgumentException("Определитель равен нулю, метод Крамера неприменим");
  }
  ```
  - Проверяет размеры и ненулевой определитель.
  - Для каждой переменной xi заменяет столбец A на B и делит определитель на det(A).

- **Метод `toTriangularForm()`**:
  ```java
  double[][] upper = copyMatrix(matrix);
  double detSign = makeUpperTriangular(upper);
  double det = detSign;
  for (int i = 0; i < upper.length; i++) {
      det *= upper[i][i];
  }
  ```
  - Копирует матрицу, чтобы не изменять исходную.
  - Приводит к треугольной форме, отслеживая знак определителя.
  - Вычисляет определитель как произведение диагональных элементов.

#### Пример использования
**Ввод**:
- Матрица A:
  ```
  [ 1  2 ]
  [ 3  4 ]
  ```
- Матрица B:
  ```
  [ 5 ]
  [ 11 ]
  ```
- Нажать "Решить методом Крамера".

**Ожидаемый вывод**:
```
Результат:
Решение методом Крамера:
x1 = 3.0
x2 = -0.5
```

### 3. `att2.java`
Содержит метод Гаусса для решения систем уравнений.

#### Общий обзор
- **Класс**: `att2`.
- **Методы**:
  - `solveByGauss()`: Решает систему.
  - `performGaussElimination()`: Выполняет алгоритм.
  - `swapRows()`: Меняет строки местами.

#### Подробный разбор
- **Метод `solveByGauss()`**:
  ```java
  double[][] augmented = new double[A.length][A[0].length + 1];
  for (int i = 0; i < A.length; i++) {
      System.arraycopy(A[i], 0, augmented[i], 0, A[0].length);
      augmented[i][A[0].length] = B[i][0];
  }
  ```
  - Создаёт расширенную матрицу [A|B].

- **Метод `performGaussElimination()`**:
  ```java
  for (int col = 0, row = 0; col < cols - 1 && row < rows; col++) {
      int pivotRow = row;
      while (pivotRow < rows && Math.abs(matrix[pivotRow][col]) < EPSILON) pivotRow++;
      if (pivotRow == rows) continue;
      if (pivotRow != row) swapRows(matrix, row, pivotRow);
  ```
  - Прямой ход: обнуляет элементы под диагональю.
  - Сравнивает ранги для определения типа решения.
  - Если решение единственное, выполняет обратный ход.

#### Пример использования
**Ввод**:
- Матрица A:
  ```
  [ 1  1 ]
  [ 2  2 ]
  ```
- Матрица B:
  ```
  [ 3 ]
  [ 6 ]
  ```
- Нажать "Решить методом Гаусса".

**Ожидаемый вывод**:
```
Результат:
Система имеет бесконечное число решений
```

### 4. `att3.java`
Содержит операции с обратными матрицами и умножением.

#### Общий обзор
- **Класс**: `att3`.
- **Методы**:
  - `calculateInverse2x2()`: Обратная матрица 2x2.
  - `multiplySquareMatrices()`: Умножение квадратных матриц.
  - `calculateInverseAnySize()`: Обратная матрица любого размера.
  - `multiplyMatrices()`, `swapRows()`: Вспомогательные.

#### Подробный разбор
- **Метод `calculateInverse2x2()`**:
  ```java
  double det = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
  double[][] inverse = {
      {matrix[1][1] / det, -matrix[0][1] / det},
      {-matrix[1][0] / det, matrix[0][0] / det}
  };
  ```
  - Использует формулу для 2x2.
  - Проверяет результат умножением A * A^-1.

- **Метод `multiplySquareMatrices()`**:
  ```java
  if (A.length != A[0].length || B.length != B[0].length || A[0].length != B.length) {
      throw new IllegalArgumentException("Матрицы должны быть квадратными и иметь совместимые размеры");
  }
  ```
  - Ограничивает умножение квадратными матрицами.

- **Метод `calculateInverseAnySize()`**:
  ```java
  double[][] augmented = new double[n][2 * n];
  for (int i = 0; i < n; i++) {
      System.arraycopy(matrix[i], 0, augmented[i], 0, n);
      augmented[i][n + i] = 1.0;
  }
  ```
  - Использует метод Гаусса-Жордана для [A|I] → [I|A^-1].

#### Пример использования
**Ввод**:
- Матрица A:
  ```
  [ 1  2 ]
  [ 3  4 ]
  ```
- Нажать "Найти обратную матрицу 2x2".

**Ожидаемый вывод**:
```
Результат:
Обратная матрица 2x2:
[-2.0000, 1.0000]
[1.5000, -0.5000]

Проверка (A * A^-1):
[1.0000, 0.0000]
[0.0000, 1.0000]
```

## Часть 3: Как использовать программу

 **Работа с интерфейсом**:
   - Введите числа в таблицы A и B.
   - Используйте кнопки "Добавить/Удалить строку/столбец" для изменения размеров.
   - Нажмите кнопку операции (например, "Вычислить определитель").
   - Результат появится в области вывода внизу.

## Часть 4: Полезные замечания
- **Ошибки ввода**: Если в ячейке не число, программа выдаст ошибку, указав ячейку.
- **Тёмная тема**: Интерфейс использует тёмные цвета для удобства.
- **Ограничения**:
  - Умножение матриц только для квадратных.
  - Для методов Крамера и Гаусса матрица B — вектор-столбец.
- **Точность**: Используется `EPSILON = 1e-10` для сравнения с нулём.

Если что-то непонятно, экспериментируйте с примерами или задавайте вопросы!
